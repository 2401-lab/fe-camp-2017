### JavaScript高级程序设计读书笔记	2018.02.03 —— 2018.02.05

[TOC]

#### 1. 语法
##### 1.1 区分大小写
** 一切区分大小写 **

##### 1.2 标识符
** 变量，函数，属性的名字或函数的参数
ECMAScript标识符采用驼峰大小写格式，如firstSecond、myCar等**

##### 1.3 注释
- 单行注释
```
// 这是单行注释
```
- 块级注释
```
   /*
    * 这是一个多行（块级）注释
	* 第二、三行开头的星号并不是必需的，但是可读性高
    */
```

##### 1.4 严格模式
- ECMAScript5引入了严格模式(strict mode)的概念,定义不同的解析和执行模型。严格模式下，ECMAScript3中的不确定行为将得到处理，对某些不安全的操作也会抛出错误。用法如下：
```
  // 在整个脚本启用严格模式，在顶部添加如下代码：
  "use strict";
  // 编译指示
  
  //在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：
  function doSomething(){
  "use strict";
  //函数体
  }
```

##### 1.5 语句
** 以分号结尾；如果省略分号，则由解析器确定语句的结尾。建议永不省略它。
始终在条件控制语句中使用代码块**

#### 2. 关键字和保留字
- 关键字 具有特定用途，可用于表示控制语句的开始或结束，或者用于执行特定的操作。例如break，if等。
- 保留字 还没有任何特定的用途，但它们有可能在将来被用作关键字。例如int，short，public等。
- 第五版缩减了保留字的数量。新增了let、yield。
- 一般来说，最好不要使用关键字和保留字作为标识符和属性名。
- 第五版中，严格模式下，eval和arguments也不能作为标识符或属性名，否则会抛出错误。

#### 3. 变量
- 动态类型，可用来保存任何类型的数据。
- 定义变量时要使用var操作符
- 未初始化的变量会保存特殊值 undefined
- 初始化：定义变量的同时就可以设置变量的值
- 不建议修改变量所保存值的类型，尽管这种操作在ECMAScript中完全有效
- 用var操作符定义的变量将成为定义该变量的作用域中的局部变量。如果在函数中使用var定义一个变量，那么这个变量在函数退出后就会被销毁。
```
function test(){
	var message = 'hi'; //局部变量
}
test(); //函数被调用时，创建变量并赋值，在此之后这个变量又会立即被销毁
alert(message); //错误
```
下面的里种种省略了var操作符，从而创建了一个全局变量：
```
function test(){
	message= "hi!"; //全局变量
}
test(); //变量有了定义，可以在函数外部的任何地方被访问
alert(message); //"hi!"
```
**虽然省略var操作符可以定义全局变量，但这并不是推荐的做法，因为这样很难维护定义在局部作用域中的全局变量。
未经声明的变量赋值会在严格模式下抛出ReferenceError错误**
- 可以使用一条语句定义多个变量，把每个变量（初始化或未初始化）用逗号分隔开即可：
```
var message = "Hi!",
	  found = false,
      age = 20;
```
- **严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。 **

#### 4. 数据类型
ECMAScript中有五种简单数据类型（基本数据类型）：
- Undefined
- Null
- Boolean
- Number
- String

和一种复杂数据类型：
- Object
**Object本质上是由一组无序的名值对组成的
ECMAScript不支持任何创建自定义类型的机制，因而所有值最终都将是上述六种数据类型之一**

##### 4.1 typeof操作符
**用于检测给定变量的数据类型**
可能返回下列某个字符串：
- "undefined"	如果这个值未定义
- "boolean"	   	如果这个值是布尔值
- "string"		如果这个值是字符串
- "number"		如果这个值是数值
- "object"		如果这个值是对象或null
- "function"	如果这个值是函数
**typeof 操作符的操作数可以是变量，也可以是数值字面量
typeof是一个操作符而不是函数圆括号可以使用但不是必需的
typeof null返回object，是因为特殊值null被认为是一个空的对象引用
技术角度来说，函数在ECMAScript中是对象，不是一种数据类型，但函数也确实有一些特殊的属性，因此通过typeof操作符来区分桉树和其他对象是很有必要的**

##### 4.2 Undefined类型
**Undefined类型只有一个值，即特殊的undefined
在使用var声明变量但未对其初始化时，这个变量的值就是undefined
ECMAScript第三版引入这个值是为了正式区分空对象指针与未经初始化的变量**

**包含undefined值的变量和尚未定义的变量还是不一样的**
```
var message;
// var age;
alert(message); //undefined
alert(age);     //产生错误
```
**对尚未声明过的变量，只能执行一项操作，即 typeof
对未初始化和未声明的变量执行typeof操作符时均会返回undefined值
显式初始化变量是明智的选择，这样typeof返回undefined时便知道这个变量尚未被声明，而不是尚未初始化**

##### 4.3 Null类型
**Null类型只有一个值：null
逻辑上看，null值表示一个空对象指针，因此typeof检测null值会返回object**
```
var car = null;
alert(typeof car); // "object"
```
**如果定义的变量准备在将来用于保存对象，那么最好将变量初始化为null而不是其他值。这样检查null值便可以知道相应的变量是否已经保存了一个对象的引用**
**实际上，undefined值派生自null，ECMA-262规定对他们的相等性检测要返回true：**
```
alert(null == undefined); //true
```

##### 4.4 Boolean类型
**该类型只有两个字面值：true和false
将一个值转换为其对应的Boolean值，可以调用转型函数Boolean（）**

##### 4.5 Number类型
**数值字面量格式**
- 十进制整数（最基本）
- 八进制整数
  第一位必须是0
  如果字面值中的数值超出了范围，前导零将会被忽略，后面的数值按十进制数值解析
- 十六进制整数
  前两位必须是0x
  字母A~F可以大写，也可以小写
**在进行算数计算时，所有八进制和十六进制表示的数值最终都将被转换为十进制数值**
- 可以保存正0和负0.二者被认为相等。

###### 4.5.1 浮点数值
- 保存浮点数值需要的内存空间是保存整数数值的两倍
- ECMAScript会不失时机地将浮点数值转换为整数值
- 如果小数点后没有跟任何数字，或浮点数本身表示的就是一个整数（如1.0），则会被转换为整数。
- 极小或极大的数用科学计数法表示
- 默认情况下，ECMAScript会将小数点后带有六个以上0的浮点数值转换为e表示法表示的数值
- 浮点数值的最高精度为17位小数，计算时精度远远不如整数（0.1 + 0.2 ！= 0.3 但 0.05 + 0.25 \== 0.3 、 0.15 + 0.15 \== 0.3）。因而永远不要测试某个特定的浮点数值。
- 舍入误差的产生来源于基于IEEE754数值格式

###### 4.5.2 数值范围
- 最小数值：`Number.MIN_VALUE`
- 最大数值：`Number.MAX_VALUE`
- \>最大数值：`Infinity`
- <最小数值：`0`
- `-Infinity`和`Infinity`
- `Infinity`无法继续参与计算
- isFinite()函数测试是否在可表示范围内

###### 4.5.3 非数NaN
- 表示一个本来要返回数值的操作数未返回数值的情况（这样不会抛出错误，例如0除返回NaN，不影响其他代码的执行）
- 任何涉及NaN的操作都会返回NaN
- NaN和任何值都不相等，包括NaN本身
- isNaN()函数在接受值时会将这个值转换为数值，任何不能转换为数值的值会导致这个函数返回true

###### 4.5.4 数值转换
将非数值转换为数值：
```
Number() parseInt() parseFloat()
```
**Number()可以用于任何数据类型，另两个函数专门用于把字符串转换成数值
三个函数对于同样的函数会返回不同的结果**
- number()
  - true和false将分别被转换为1和0
  - 如果是数字值，只是简单的传入和返回
  - 如果是null值，返回0
  - 如果是undefined，返回NaN
  - 如果是字符串
    - 字符串只含数字，将其转换为十进制数值
    - 字符串中包含有效的浮点格式，则转换为对应的浮点数值
    - 字符串中包含有效的十六进制格式，则将其转换为相同大小的十进制整数值
    - 空字符串转换为0
    - 其它情况下转换为NaN
  - 如果是对象，则调用对象的valueOf()方法，然后按照前面的规则转换返回的值。如果转换的结果为NaN，则调用对象的toString()方法，然后再次按照前面的规则转换返回的字符串值
```
var num1 = Number("Hello world!"); // NaN
var num2 = Number(""); // 0
var num3 = Number("000011") // 11
var num4 = Number(true) // 1
```
- parseInt()
**由于Number()在转换字符串时比较复杂且不够合理，因此在处理整数时更常用的是parseInt()函数**
**忽略字符串前面的空格，直到找到第一个非空格字符**
  - 如果第一个字符不是数字字符或者负号，parseInt()返回NaN
**parseInt()转换空字符串返回NaN，然而Number()返回0**
  - 如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完毕所有后续字符或者遇到了一个非数值字符
  - parseInt()会识别出各种整数格式
```
var num1 = parseInt("1234blue"); // 1234
var num2 = parseInt(""); // NaN
var num3 = parseInt("0xA"); // 10（十六进制）
var num4 = parseInt(22.5); // 22
var num5 = parseInt("070"); // 56（八进制）
var num6 = parseInt("70"); // 70（十进制）
var num7 = parseInt("0xf"); // 15（十六进制）
```
**ECMAScript 5中parseInt()已经不具有解析八进制值的能力，前导零被认为无效**
  - 可以为这个函数提供第二个参数：转换时使用的基数
```
var num = parseInt("0xAF", 16); // 175
var num1 = parseInt("AF", 16); // 175
var num2 = parseInt("AF"); // NaN
var num3 = parseInt("10", 2) // 2
var num4 = parseInt("10", 8) // 8
var num5 = parseInt("10", 10) // 10
var num6 = parseInt("10", 16) // 16
```
** 建议无论在任何时候都明确指明基数 **
- parseFloat()
  - 第一个小数点有效，第二个则无效
  - 始终忽略先导0
  - 可识别所有浮点数格式，但16进制格式的字符串会被转换为0
  - 因此实际上这个函数只解析十进制值，他没有用第二个数指定基数的用法
  - 若字符串可直接解析为一个整数，则只返回一个整数
```
"1234blue" --> 1234
"0xA" --> 0
"22.5" --> 22.5
"22.34.5" --> 22.34
"0908.5" --> 908.5
"3.125e7" --> 31250000
```

##### 4.6 String类型
** 用于表示由0或多个Unicode字符组成的字符序列，即字符串
双引号或单引号表示，左右括号必须匹配 **
###### 4.6.1 字符字面量
- 字符字面量，也叫转义序列，用于表示非打印字符，或者有其他用途的字符
- 可以出现在字符串中任意位置，也将被作为一个字符来解析
- length属性访问字符串的长度

###### 4.6.2 字符串的特点
- ECMAScript字符串是不可变的

###### 4.6.3 转换为字符串
- tostring()方法
  - 数值、布尔值、对象和字符串值都有该方法，null和undefined值没有
  - 调用数值的该方法时可以传递一个参数：输出数值的基数。默认情况下返回的是十进制格式。
- string()方法
  - 可以将任何类型的值转换为字符串
  - null转换为"null"，undefined转换为"undefined"
  - 其余调用tostring()方法
  - **把某个值转换为字符串，可以使用加号操作符把它与一个空字符串加在一起**

##### 4.7 object类型
**ECMAScript中的对象其实就是一组数据和功能的集合
对象可以通过执行new操作符后跟要创建的对象类型来创建
不给构造函数传递参数，可以省略构造函数的括号，但不推荐**
```
var o = new Object();
var o = new Object; // 有效但不推荐
```
**仅仅创建Object的实例并没有什么用处，Object类型是所有他的实例的基础
Object类型所具有的任何属性和方法也同样存在于更具体的对象中
ECMA-262中对象的行为不一定适用于JavaScript中的其他对象，例如宿主对象：BOM、DOM中的对象，由宿主实现提供和定义**

#### 5. 操作符
- 算术操作符
- 位操作符
- 关系操作符
- 相等操作符

**应用于对象时，相应的操作符都会调用对象的valueOf()或toString()方法，以便取得可以操作的值**

##### 5.1 一元操作符
- 递增递减操作符
  - 应用于字符串时，先将其转换为数字值，再减一。否则将值设为NaN
  - false转换为0再减1
  - true转换为1再减1
  - 应用于对象时，先调用valueOf()方法，再调用toString()方法。应用前述规则。

- 一元加和减操作符
  - 主要运用于基本的算术运算，也可以用于转换数据类型
  - `+`放在数值的前面不会产生影响
  - `+`放在非数值的前面等同于调用Number()函数
  - `-`主要用于表示负数
  - `-`放在非数值前面等于`+`完取负

```
s = false;
s--; // 0
s; // -1
```

##### 5.2 位操作符
- 位操作符按内存中表示数值的位来操作数值
- ECMAScript中所有的数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值
- 现将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位
- 有符号整数第32位用于表示数值的符号：0正数，1负数 符号位
- 负数使用二进制补码格式存储
  - 求绝对值的二进制码
  - 求二进制反码
  - 求得的二进制反码+1
```
  var num = -18;
  num.toString(2); // "-10010"
```
- 对特殊的NaN和Infinity值应用位操作时，这两个值都会被当作0来处理
- 对非数值应用位操作时，自动用Number()函数将该值转换为一个数值

###### 5.2.1 按位非
- 表示 ~
- 结果是返回数值的反码
- 按位非操作的本质：操作数的负值减1

###### 5.2.2 按位与
- 表示 &

###### 5.2.3 按位或
- 表示 |

###### 5.2.4 按位异或
- 表示 ^

###### 5.2.5 左移
- 表示 <<
- 等价于乘以2的n次方
- 不影响操作数的符号位

###### 5.2.6 有符号的右移
- 表示 >>
- 操作符会将数值向右移动，但保留符号位
- 空位出现在符号位的右侧，使用符号位的值来填充所有空位

###### 5.2.7 无符号右移
- 表示 >>>
- 将数值所有32位都右移，以0来填充空位
- 负数的右移变化很大

##### 5.3 布尔操作符
- 非
- 与
- 或

###### 5.3.1 逻辑非
- 表示 ！
- 可以应用于任何值，返回一个布尔值
```
对象 -> false
空字符串 -> true
非空字符串 -> false
0 -> true
非0(包括infinity) -> false
null -> true
NaN -> true
undefined -> true
```
- !! = boolean()

###### 5.3.2 逻辑与
- 表示&&
- 可应用于任何类型的操作数，而不仅仅是布尔值
  - 第一个操作数是对象，则返回第二个操作数
  - 第二个操作数是对象，当且仅当第一个操作数的求值结果是true，返回该对象
  - 两个操作数都是对象，则返回第二个操作数
  - 有一个操作数是null、NaN、undefined，返回对应值
- 短路操作

###### 5.3.3 逻辑或
- 表示 ||
- 如果有一个操作数不是布尔值
  - 第一个操作数是对象，返回第一个操作数
  - 第一个操作数的求值结果为false，则返回第二个操作数
  - 两个都是对象，返回第一个操作数
  - 两个都是null/NaN/undefined，返回对应值
- 短路操作
- 应用：
```
var myObject = preferredObject || backupObject
```

##### 5.4 乘性操作符
** 操作数为非数值的情况下会执行自动的类型转换 **
- 乘法
- 除法
- 求模
- 0 * Infinity = NaN
- Infinity / Infinity = 0 / 0 = NaN
- 非0 / 0 = Infinity or -Infinity
- Infinity / 非0 = Infinity
- NaN参与运算结果为NaN
- 具体细节自己去试一试

##### 5.5 加性操作符
** 操作数为非数值的情况下会执行自动的类型转换 **
** 有字符串参与运算则进行字符串的拼接 **
** 改变优先级请使用括号 **

##### 5.6 关系操作符
- 两个都是字符串，比较二者对应的字符编码值
- 大写字母的字符编码全部小于小写字母的字符编码
- 特例
```
"23" < "3" // true
"23" < 3 // false
NaN < 3 // false
NaN >= 3 // false
```

##### 5.7 相等操作符
**
相等和不相等——先转换在比较
全等和不全等——仅比较不转换
**
###### 5.7.1 相等和不相等
- 表示 ==  !=
- 先转换操作数（通常称为强制转型， 再比较他们的相等性）
  - 有布尔值则先转换为数值
  - 字符串和数值，字符串转为数值
  - 对象的话调用其valueOf()方法
  - null 和 undefined 是相等的
  - NaN != NaN
  - 对象比较时比的是他们是否指向同一对象

###### 5.7.2 全等和不全等
- 表示 === !==
- null == undefined
- null !== undefined
- 推荐使用全等和不全等操作符

##### 5.8 条件操作符
`? :`

##### 5.9 复制操作符
- `=`
- 复合赋值
  - 乘性
  - 减性
  - 位运算符
- 仅仅是简化赋值操作，不会带来性能上的提升

##### 5.10 逗号操作符
- 在一条语句中执行多个操作
- 结果是右边的值

#### 6. 语句
**使用while语句做不到的，使用for循环也做不到
ECMAScript中不存在块级作用域，因此循环体内定义的变量也可以在外部访问到**
- if
- while
- do while
- for
- for in
**建议在使用for-in 循环之前，先检测确认该对象的值不是null 或undefined。 **
```
for (var propName in window){
	document.write(propName); // 保证局部变量,推荐使用var
}
// ECMAScript 对象的属性没有顺序。因此，通过for-in 循环输出的属性名的顺序是不可预测的。
// 具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。
```
- label
  用法: `label: statement`
```
start: for (var i = 0;i < count;i++) {
	alert(i);
}
```
** 这个例子中定义的start 标签可以在将来由break 或continue 语句引用。加标签的语句一般都
要与for 语句等循环语句配合使用。 **
- break 和 continue
- with
  用法： with(expression) statement;
  ```
  var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;
可改为
with(location){
var qs = search.substring(1);
var hostName = hostname;
var url = href;
}
```
** 在这个重写后的例子中，使用with 语句关联了location 对象。这意味着在with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location 对象中是否有同名的属性。如果发现了同名属性，则以location 对象属性的值作为变量的值
严格模式不允许使用with语句，而且在开发大型应用程序时，不建议使用with语句**
- switch
  - 可以在switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。使用权等判断，不会更改数据类型
  - 每个case 的值不一定是常量，可以是变量，甚至是表达式

#### 7. 函数
- 声明 function关键字
- 推荐的做法是：要么让函数始终都返回一个值，要么永远都不要返回值。

##### 7.1 理解参数
- ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）
- 实际上，在函数体内可以通过arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。
- arguments 对象只是与数组类似（它并不是Array 的实例），因为可以使用方括号语法访问它的每一个元素（即第一个元素是arguments[0]，第二个元素是argumetns[1]，以此类推），使用length 属性来确定传递进来多少个参数。
- ECMAScript函数的一个重要特点：命名的参数只提供便利，但不是必需的
```
function howManyArgs() {
alert(arguments.length);
}
howManyArgs("string", 45); //2
howManyArgs(); //0
howManyArgs(12); //1
```
- arguments对象可以和命名参数一起使用
- argument[0]的值与第一个命名参数**保持同步**，但是这两个值的内存空间是独立的
- 如果只传入了一个参数，那么为arguments[1]设置的值不会反应到命名参数中。这是因为**arguments 对象的长度是由传入的参数个数决定的**，不是由定义函数时的命名参数的个数决定的
- 没有传递值的命名参数将自动被赋予undefined

##### 7.2 没有重载
** 没有重载，定义两个名字相同的函数，则后定义的函数覆盖先定义的函数 **

#### 8 总结
- 5种基本类型undefined、null、number、string、boolean，一种复合类型object
- number类型可用于表示整数和浮点数
- 未指定返回值的函数返回的是一个特殊的undefined值
- 没有函数签名的概念，其函数参数是以类数组的形式传递
- 可在函数里通过arguments访问这些参数
- 函数不能重载